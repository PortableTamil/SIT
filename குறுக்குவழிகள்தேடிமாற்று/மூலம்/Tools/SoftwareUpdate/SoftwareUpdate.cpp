/*
Copyright (C) 2004 Jacquelin POTIER <jacquelin.potier@free.fr>
Dynamic aspect ratio code Copyright (C) 2004 Jacquelin POTIER <jacquelin.potier@free.fr>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

//-----------------------------------------------------------------------------
// Object: manage Software Update
//-----------------------------------------------------------------------------
#include "softwareupdate.h"

//-----------------------------------------------------------------------------
// Name: CheckForUpdate
// Object: 
//          1) get last software release info from an xml file like
//          <PROGRAM_VERSION>3.1.3.0</PROGRAM_VERSION><PROGRAM_CHANGE_INFO>Software description</PROGRAM_CHANGE_INFO> (not case sensitive for markup)
//          this information is present in PAD files like those generated by PADGen
//          2) if a new version exist, allow user to download new version
// Parameters :
//     IN TCHAR* UrlOfLastVersionInfoFile : url of xml file
//     IN DWORD VersionNbDigits : number of digits to check
//     IN TCHAR* DownloadLink : download link of last version
//     IN BOOL bDisplayDialog : display error message
//     OUT BOOL* pbNewVersionIsAvailable : return TRUE if a new version is available (can be null)
//     IN BOOL bShowOnlyNewVersionMsg if TRUE don't show message to say your version is up to date
//     IN HWND hWndDialog : owning window hwnd
//     return : TRUE on success
//-----------------------------------------------------------------------------
BOOL CSoftwareUpdate::CheckForUpdate(IN TCHAR* UrlOfLastVersionInfoFile,IN DWORD VersionNbDigits,IN TCHAR* DownloadLink,IN HWND hWndDialog)
{
    BOOL bNewVersionIsAvailable;
    return CSoftwareUpdate::CheckForUpdate(UrlOfLastVersionInfoFile,VersionNbDigits,DownloadLink,TRUE,&bNewVersionIsAvailable,FALSE,hWndDialog);
}
BOOL CSoftwareUpdate::CheckForUpdate(IN TCHAR* UrlOfLastVersionInfoFile,IN DWORD VersionNbDigits,IN TCHAR* DownloadLink,IN BOOL bDisplayDialog,OUT BOOL* pbNewVersionIsAvailable,IN BOOL bShowOnlyNewVersionMsg,IN HWND hWndDialog)
{
    BOOL bSuccess=FALSE;
    char* pszContentUpper=NULL;
    PBYTE VersionInfoFileContent=NULL;
    ULONG VersionInfoFileContentSize=0;
    char* pszReport=NULL;
    TCHAR AppPath[MAX_PATH];

    if (bShowOnlyNewVersionMsg)
        bDisplayDialog=FALSE;// hide error + no new version
    // default return value
    if (pbNewVersionIsAvailable)
        *pbNewVersionIsAvailable = FALSE;

    // get app path
    if(!CStdFileOperations::GetAppPath(AppPath,MAX_PATH))
        return FALSE;

    // get app version
    CVersion Version;
    if(!Version.Read(AppPath))
        return FALSE;

    // get file
    CHTTP Http;
    if (!Http.Get(UrlOfLastVersionInfoFile,&VersionInfoFileContent,&VersionInfoFileContentSize))
    {
        if (bDisplayDialog)
            Http.ShowLastError(hWndDialog);
        goto CleanUp;
    }

    // convert xml content to upper to do insensitive search
    pszContentUpper=_strdup((char*)VersionInfoFileContent);
    _strupr(pszContentUpper);

    char* pszVersion;
    DWORD VersionLength;
    char* pszDescription;
    DWORD DescriptionLength;
    char* pPointerAfterEndingMarkup;
    if(!CSoftwareUpdate::ReadXMLMarkupContent(pszContentUpper,XML_MARKUP_VERSION,&pszVersion,&VersionLength,&pPointerAfterEndingMarkup))
    {
        if (bDisplayDialog)
            MessageBox(hWndDialog,_T("Invalid update information file"),_T("Error"),MB_OK|MB_ICONERROR | MB_SYSTEMMODAL);
        goto CleanUp;
    }
    // get non upper value (avoid to act on upper buffer too for next markup searches)
    pszVersion=(char*)VersionInfoFileContent+(pszVersion-pszContentUpper);
    pszVersion[VersionLength]=0;

    // Notice program version is like "<Program_Version>1.5.0</Program_Version>" with PadGen
    // so pszVersion contains something like "1.5.0"
    DWORD AvailableVersionMajor=0;
    DWORD AvailableVersionMinor=0;
    DWORD AvailableVersionBuild=0;
    DWORD AvailableVersionDigists;
    AvailableVersionDigists = sscanf(pszVersion,"%u.%u.%u",&AvailableVersionMajor,&AvailableVersionMinor,&AvailableVersionBuild);

    DWORD CheckingStep = __min(AvailableVersionDigists,VersionNbDigits);

    BOOL NewVersionExists = FALSE;
    DWORD CurrentVersionMajor=0;
    DWORD CurrentVersionMinor=0;
    DWORD CurrentVersionBuild=0;
    TCHAR PrettyVersion[50];
    if (CVersion::GetPrettyVersion(Version.FileVersion,VersionNbDigits,PrettyVersion,50))
    {
        switch(VersionNbDigits)
        {
        default: // >=3
            _stscanf(PrettyVersion,_T("%u.%u.%u"),&CurrentVersionMajor,&CurrentVersionMinor,&CurrentVersionBuild);
            break;
        case 2:
            _stscanf(PrettyVersion,_T("%u.%u"),&CurrentVersionMajor,&CurrentVersionMinor);
            break;
        case 1:
            _stscanf(PrettyVersion,_T("%u"),&CurrentVersionMajor);
            break;
        }
        
        if (CurrentVersionMajor<AvailableVersionMajor)
            NewVersionExists = TRUE;
        else
        {
            if (CurrentVersionMajor == AvailableVersionMajor)
            {
                if (CheckingStep>1)
                {
                    if (CurrentVersionMinor<AvailableVersionMinor)
                        NewVersionExists = TRUE;
                    else
                    {
                        if (CurrentVersionMinor==AvailableVersionMinor)
                        {
                            if (CheckingStep>2)
                            {
                                if (CurrentVersionBuild<AvailableVersionBuild)
                                    NewVersionExists = TRUE;
                            }
                        }
                    }
                }
            }
        }
    }


    if (!NewVersionExists)
    {
        if (bDisplayDialog)
            MessageBox(hWndDialog, _T("Your software is up to date"),_T("Information"),MB_OK|MB_ICONINFORMATION | MB_SYSTEMMODAL);
        bSuccess=TRUE;
        goto CleanUp;
    }
    // else : NewVersionExists
    if (pbNewVersionIsAvailable)
        *pbNewVersionIsAvailable = TRUE;

    if (bDisplayDialog || bShowOnlyNewVersionMsg)
    {
        // read changes informations
        CSoftwareUpdate::ReadXMLMarkupContent(pszContentUpper,XML_MARKUP_DESCRIPTION,&pszDescription,&DescriptionLength,&pPointerAfterEndingMarkup);
        // get non upper value (avoid to act on upper buffer too for next markup searches)
        pszDescription=(char*)VersionInfoFileContent+(pszDescription-pszContentUpper);
        if (pszDescription)
            pszDescription[DescriptionLength]=0;

        pszReport=new char[MAX_PATH+VersionLength+DescriptionLength];

        sprintf(pszReport,"A new version (%s) is available\r\n",pszVersion);
        if (pszDescription)
        {
            if (*pszDescription)
            {
                strcat(pszReport,"Changes : ");
                strcat(pszReport,pszDescription);
                strcat(pszReport,"\r\n");
            }
        }
        strcat(pszReport,"\r\nDo you want to download new version now ?");

#if (defined(UNICODE)||defined(_UNICODE))
        TCHAR* pszUnicode;
        CAnsiUnicodeConvert::AnsiToUnicode(pszReport,&pszUnicode);
        CSoftwareUpdate::DisplayNewVersionInfos(pszUnicode,DownloadLink,hWndDialog);
        free(pszUnicode);
#else
        CSoftwareUpdate::DisplayNewVersionInfos(pszReport,DownloadLink,hWndDialog);
#endif
    }

    bSuccess=TRUE;
CleanUp:
    if (pszReport)
        delete[] pszReport;
    if (pszContentUpper)
        free(pszContentUpper);
    if (VersionInfoFileContent)
        delete[] VersionInfoFileContent;
    return bSuccess;
}
//-----------------------------------------------------------------------------
// Name: ReadXMLMarkupContent
// Object: read xml content. This func allow version soft read ascii saved files
//          or ansi version read unicode saved files
// Parameters :
//     in  : TCHAR* FullString : buffer supposed to contain markup
//           TCHAR* Markup : markup
//     out : TCHAR** ppszContent : content of the markup in the same encoding as FullString
//           DWORD* pContentLength : content length in TCHAR
//           TCHAR** pPointerAfterEndingMarkup : pointer after the markup
//     return : TRUE if Markup found, FALSE else
//-----------------------------------------------------------------------------
BOOL CSoftwareUpdate::ReadXMLMarkupContent(char* FullString,char* Markup,char** ppszContent,DWORD* pContentLength,char** pPointerAfterEndingMarkup)
{
    BOOL bSuccess=FALSE;
    *ppszContent=0;
    *pContentLength=0;
    *pPointerAfterEndingMarkup=0;

    if (IsBadReadPtr(FullString,sizeof(char*)))
        return FALSE;
    if (*FullString==0)
        return FALSE;

    size_t MarkupSize=strlen(Markup);
    char* pszStartTag=new char[MarkupSize+3];
    char* pszEndTag=new char[MarkupSize+4];
    char* pszNoDataTag=NULL;
    char* pszStartTagPos;
    char* pszEndTagPos;
    char* pszNoDataTagPos;

    // make xml start tag and end tag (Tag --> <Tag> and </Tag>)
    sprintf(pszStartTag,"<%s>",Markup);
    sprintf(pszEndTag,"</%s>",Markup);
    

    // search xml start tag and end tag
    pszStartTagPos=strstr(FullString,pszStartTag);
    pszEndTagPos=strstr(FullString,pszEndTag);
    // if none found
    if ((pszStartTagPos==0)||(pszEndTagPos==0))
    {
        if ((pszStartTagPos==0)&&(pszEndTagPos==0))
        {
            pszNoDataTag=new char[MarkupSize+5];
            sprintf(pszNoDataTag,"<%s />",Markup);
            pszNoDataTagPos=strstr(FullString,pszNoDataTag);
            if (pszNoDataTagPos)
            {
                *ppszContent=pszNoDataTagPos;
                *pContentLength=0;
                *pPointerAfterEndingMarkup=pszNoDataTagPos+MarkupSize+4;
                bSuccess=TRUE;
            }   
        }

        goto CleanUp;
    }
    // if bad positions
    if (pszEndTagPos<pszStartTagPos)
        goto CleanUp;

    // get content of markup
    *ppszContent=pszStartTagPos+MarkupSize+2;
    *pContentLength=(DWORD)(pszEndTagPos-*ppszContent);
    *pPointerAfterEndingMarkup=pszEndTagPos+MarkupSize+3;

    bSuccess=TRUE;
CleanUp:
    if (pszNoDataTag)
        delete[] pszNoDataTag;
    delete[] pszStartTag;
    delete[] pszEndTag;

    return bSuccess;
}

//-----------------------------------------------------------------------------
// Name: DisplayNewVersionInfos
// Object: Display new version information and open default download manager if 
//         user wants to download new version
// Parameters :
//     in  : TCHAR* pszNewVersionDownloadQuery : query text to download new version
//           TCHAR* DownloadLink : download link (url)
//     out :
//     return : 
//-----------------------------------------------------------------------------
void CSoftwareUpdate::DisplayNewVersionInfos(TCHAR* pszNewVersionDownloadQuery,TCHAR* DownloadLink,HWND hWndDialog)
{
    if (::MessageBox(hWndDialog,pszNewVersionDownloadQuery,_T("Update"),MB_YESNO|MB_ICONINFORMATION)==IDYES)
    {
        ::ShellExecute(hWndDialog,_T("open"),DownloadLink,NULL,NULL,SW_SHOWDEFAULT);
    }
}